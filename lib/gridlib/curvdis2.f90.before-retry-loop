!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
   subroutine curvdis2 (ndat, xdat, ydat, n, power, ismooth, lunout, &
                        arcs_only, x, y, ier)
!
!  CURVDIS2 has the same calling sequence as CURVDIS, but it applies geometric
!  normalization to the data first, then denormalizes results before returning.
!  This means the coordinate with the larger data range is transformed to [0,1],
!  and the other coordinate is scaled by the same factor to preserve shape,
!  along with being shifted to the origin, before curvatures are calculated.
!  The purpose is to avoid extreme curvature values from tiny geometries that
!  can give undesirable curvature-based point distributions.
!
!  Note that the data points are normalized/denormalized in place.
!
!  11/08/12  D.A.Saunders  Application of existing utilities for use by
!                          CAPSULE_GRID.
!
!  Author:  David Saunders, ERC, Inc. at NASA Ames Research Center, CA.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   implicit none

!  Arguments:

   integer, intent (in)    :: ndat       ! Number of input curve points
   real,    intent (inout) :: xdat(ndat) ! X coordinates of input curve
   real,    intent (inout) :: ydat(ndat) ! Y coordinates of input curve
   integer, intent (in)    :: n          ! Number of output curve points
   real,    intent (in)    :: power      ! Exponent for spacing function;
                                         ! controls the point clustering.
                                         ! POWER must be in [0., 1.];
                                         ! 0.0 produces uniform spacing;
                                         ! 1.0 maximizes the curvature effect;
                                         ! 0.5 is suggested
   integer, intent (in)    :: ismooth    ! 0 => no smoothing;
                                         ! 1 => smooth shape function only;
                                         ! 2 => smooth redistributed arcs only;
                                         ! 3 => perform both sets of smoothings
   integer, intent (in)    :: lunout     ! Logical unit for showing convergence
                                         ! history; LUNOUT < 0 suppresses it
   logical, intent (in)    :: arcs_only  ! T => skip calculations of X & Y(1:N)
                                         ! but return revised arcs as X(1:N)
   real,    intent (out)   :: x(n), y(n) ! X & Y coordinates of output curve,
                                         ! unless ARCS_ONLY = T, in which case
                                         ! just the arc-lengths are returned as
                                         ! X(1:N)
   integer, intent (out)   :: ier        ! 0 => no errors;
                                         ! 1 => POWER is out of range;
                                         ! 2 => failure in ARBDIS
!  Local constants:

   integer, parameter :: ndim = 2  ! Any "z" argument is ignored by get/usescale

!  Local variables:

   integer :: ier_local
   real    :: scale(ndim), shift(ndim)

!  Execution:

   call getscale ('G', ndim, ndat, xdat, ydat, ydat, scale, shift, ier_local)
   call usescale ('N', ndim, ndat, xdat, ydat, ydat, scale, shift, ier_local)
   call curvdis  (ndat, xdat, ydat, n, power, ismooth, lunout, arcs_only, &
                  x, y, ier)
   if (arcs_only) y(:) = x(:) ! So it's not undefined when usescale is called

   call usescale ('D', ndim, ndat, xdat, ydat, ydat, scale, shift, ier_local)
   call usescale ('D', ndim, n,    x,    y,    ydat, scale, shift, ier_local)

   end subroutine curvdis2
