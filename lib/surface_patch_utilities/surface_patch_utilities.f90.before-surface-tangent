!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   module surface_patch_utilities

!  This module packages a few utilities for manipulating surface grid patches
!  and optional surface data.  It was prompted by a need to reorganize patches
!  into standard form for comparison of corresponding results.
!
!     centroids_areas  (patchin, patchout)     patchout%xyzf = centroids & areas
!     clone_grid       (nb, nf, grid1, grid2)  Allocates and copies header info.
!     patch_data_range (patch)       assigns min & max values of x, y, z
!     reflect_x_y_or_z (patch, n)    reflects coordinate n about plane through O
!     reverse_patch_i  (patch, nf)   reverses the i indices
!     reverse_patch_j  (patch, nf)   reverses the j indices
!     scale_and_shift  (patch, scale, dx, dy, dz, pout)   scales/shifts x, y, z
!     swap_coordinates (patch, m, n) swaps coordinates m and n
!     transpose_patch  (patch, nf)   swaps i and j in place
!     update_patch     (patch1, patch2, nf)    transfers patch1 to patch2
!     ????                           what else?
!
!  04/09/05  D. A. Saunders   Initial implementation for Shuttle cavity grids.
!  06/16/05     "      "      Added scale and/or shift option.
!  06/20/05     "      "      Added calculation of cell centroids and areas.
!  02/22/06     "      "      Premature STOPs on Steve Alter's Opteron were
!                             traced to an ier /= 0 test in centroids_areas that
!                             should not have been there.
!  03/31/09     "      "      Added update_patch option.
!  07/26/10     "      "      %mi, %mj, %mk are now set in centroids_areas
!                             in case of I/O via xyzq_io.
!
!  Author:  David Saunders, ELORET/NASA Ames Research Center, Moffett Field, CA
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   use grid_block_structure ! From Tecplot_io module, or equivalent

   implicit none

   public :: centroids_areas
   public :: clone_grid
   public :: patch_data_range
   public :: reflect_x_y_or_z
   public :: reverse_patch_i
   public :: reverse_patch_j
   public :: scale_and_shift
   public :: swap_coordinates
   public :: transpose_patch
   public :: update_patch

   contains

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine centroids_areas (patchin, patchout)

!     For the given surface patch and a companion "patch" with none of its
!     fields allocated yet, assign companion dimensions to represent the number
!     of cells rather than vertices. Allocate new %x, %y, %z fields and a single
!     function field and return them with the cell centroids and areas.
!
!     [Use of the Tecplot_io package with its grid_block_structure module does
!     not permit adding further fields to that derived data type, so the work-
!     around is to declare a second array of this data type at the higher level
!     and construct ancillary fields in the companion array elements.]
!
!     Centroids are simply the average coordinates of the vertices.
!
!     Areas are half the magnitudes of the cross-products of the two diagonals
!     of each quadrilateral cell, ASSUMING THE CELLS ARE (ESSENTIALLY) PLANAR.
!
!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (in)    :: patchin   ! %x,y,z and %ni,nj defined
      type (grid_type), intent (inout) :: patchout  ! Fields are assumed to be
                                                    ! unallocated on input;
                                                    ! returned with cell-related
                                                    ! quantities described above
!     Local constants:

      real, parameter :: fourth = 0.25, half = 0.5

!     Local variables:

      integer :: i, j, ni, nj
      real    :: p(3), q(3), r(3)

!     Execution:

      ni = patchin%ni - 1;  patchout%ni = ni;  patchout%mi = ni ! In case of I/O
      nj = patchin%nj - 1;  patchout%nj = nj;  patchout%mj = nj
                            patchout%nk = 1;   patchout%mk = 1

      allocate (patchout%x(ni,nj,1), patchout%y(ni,nj,1), &
                patchout%z(ni,nj,1), patchout%q(1,ni,nj,1))

      do j = 1, nj
         do i = 1, ni
            patchout%x(i,j,1) = fourth * &
               (patchin%x(i,  j,1) + patchin%x(i+1,  j,1) + &
                patchin%x(i,j+1,1) + patchin%x(i+1,j+1,1))
            patchout%y(i,j,1) = fourth * &
               (patchin%y(i,  j,1) + patchin%y(i+1,  j,1) + &
                patchin%y(i,j+1,1) + patchin%y(i+1,j+1,1))
            patchout%z(i,j,1) = fourth * &
               (patchin%z(i,  j,1) + patchin%z(i+1,  j,1) + &
                patchin%z(i,j+1,1) + patchin%z(i+1,j+1,1))

            p(1) = patchin%x(i+1,j+1,1) - patchin%x(i,j,1)
            p(2) = patchin%y(i+1,j+1,1) - patchin%y(i,j,1)
            p(3) = patchin%z(i+1,j+1,1) - patchin%z(i,j,1)

            q(1) = patchin%x(i,j+1,1) - patchin%x(i+1,j,1)
            q(2) = patchin%y(i,j+1,1) - patchin%y(i+1,j,1)
            q(3) = patchin%z(i,j+1,1) - patchin%z(i+1,j,1)

            r(1) = p(2) * q(3) - p(3) * q(2) ! Vector product
            r(2) = p(3) * q(1) - p(1) * q(3)
            r(3) = p(1) * q(2) - p(2) * q(1)
            
            patchout%q(1,i,j,1) = half * sqrt (r(1)**2 + r(2)**2 + r(3)**2)
         end do
      end do

      end subroutine centroids_areas

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine clone_grid (nb, nf, grid1, grid2)

!     Set up a copy of a multiblock grid by allocating the blocks and
!     transcribing the header information (only).

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      integer, intent (in)          :: nb      ! # blocks
      integer, intent (in)          :: nf      ! nf > 0 means copy %mi, etc. too
      type (grid_type), intent (in) :: grid1(nb)
      type (grid_type), pointer     :: grid2(:)

!     Local variables:

      integer :: ib

!     Execution:

      allocate (grid2(nb))

      do ib = 1, nb
         grid2%ni = grid1%ni
         grid2%nj = grid1%nj
         grid2%nk = grid1%nk
         if (nf > 0) then
            grid2%mi = grid1%mi
            grid2%mj = grid1%mj
            grid2%mk = grid1%mk
         end if
      end do

      end subroutine clone_grid

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine patch_data_range (patch)

!     Assign min & max values of x, y, z for the given surface patch (nk = 1).

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch

!     Local constants:

      real, parameter :: big = 1.e+32

!     Local variables:

      integer :: i, j

!     Execution:

      patch%xmin = big;  patch%xmax = -big
      patch%ymin = big;  patch%ymax = -big
      patch%zmin = big;  patch%zmax = -big

      do j = 1, patch%nj
         do i = 1, patch%ni
            patch%xmin = min (patch%x(i,j,1), patch%xmin)
            patch%xmax = max (patch%x(i,j,1), patch%xmax)
            patch%ymin = min (patch%y(i,j,1), patch%ymin)
            patch%ymax = max (patch%y(i,j,1), patch%ymax)
            patch%zmin = min (patch%z(i,j,1), patch%zmin)
            patch%zmax = max (patch%z(i,j,1), patch%zmax)
         end do
      end do

      end subroutine patch_data_range

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine reflect_x_y_or_z (patch, n)

!     Reflect the indicated coordinate in the appropriate plane through (0,0,0).

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      integer, intent (in) :: n           ! n = 1, 2, 3  <->  reflect x, y, z

!     Local variables:

      integer :: i, j

!     Execution:

      select case (n)
         case (1)
            patch%x = -patch%x
         case (2)
            patch%y = -patch%y
         case (3)
            patch%z = -patch%z
      end select

      end subroutine reflect_x_y_or_z

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine reverse_patch_i (patch, nf)

!     Reverse the i indices of a surface patch, in-place.

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      integer,          intent (in)    :: nf   ! # function values; nf >= 0

!     Local variables:

      integer :: i, ii, j, ni, niby2
      real    :: t, tq(nf)

!     Execution:

      ni = patch%ni;  niby2 = (ni + 1) / 2

      do j = 1, patch%nj
         ii = ni
         do i = 1, niby2
            t               = patch%x(i, j,1)
            patch%x(i, j,1) = patch%x(ii,j,1)
            patch%x(ii,j,1) = t
            t               = patch%y(i, j,1)
            patch%y(i, j,1) = patch%y(ii,j,1)
            patch%y(ii,j,1) = t
            t               = patch%z(i, j,1)
            patch%z(i, j,1) = patch%z(ii,j,1)
            patch%z(ii,j,1) = t
            ii = ii - 1 
         end do
      end do

      if (nf > 0) then

         ni = patch%mi;  niby2 = (ni + 1) / 2

         do j = 1, patch%mj
            ii = ni
            do i = 1, niby2
               tq                = patch%q(:,i, j,1)
               patch%q(:,i, j,1) = patch%q(:,ii,j,1)
               patch%q(:,ii,j,1) = tq
               ii = ii - 1  
            end do  
         end do

      end if

      end subroutine reverse_patch_i

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine reverse_patch_j (patch, nf)

!     Reverse the j indices of a surface patch, in-place.

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      integer,          intent (in)    :: nf   ! # function values; nf >= 0

!     Local variables:

      integer :: i, j, jj, nj, njby2
      real    :: t, tq(nf)

!     Execution:

      nj = patch%nj;  njby2 = (nj + 1) / 2

      do i = 1, patch%ni
         jj = nj
         do j = 1, njby2
            t               = patch%x(i,j, 1)
            patch%x(i,j, 1) = patch%x(i,jj,1)
            patch%x(i,jj,1) = t
            t               = patch%y(i,j, 1)
            patch%y(i,j, 1) = patch%y(i,jj,1)
            patch%y(i,jj,1) = t
            t               = patch%z(i,j, 1)
            patch%z(i,j, 1) = patch%z(i,jj,1)
            patch%z(i,jj,1) = t
            jj = jj - 1
         end do
      end do

      if (nf > 0) then

         nj = patch%mj;  njby2 = (nj + 1) / 2

         do i = 1, patch%mi
            jj = nj
            do j = 1, njby2
               tq                = patch%q(:,i,j, 1)
               patch%q(:,i,j, 1) = patch%q(:,i,jj,1)
               patch%q(:,i,jj,1) = tq
               jj = jj - 1
            end do
         end do

      end if

      end subroutine reverse_patch_j

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine scale_and_shift (patch, scale, dx, dy, dz, patch_out) 

!     Scale all of x, y, z and/or shift any of x, y, z, in-place or not:
!
!                  x_out <-- scale * x + dx          etc.
!
!     Unit scaling and zero shifts are not suppressed.

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      real, intent (in)                :: scale, dx, dy, dz
      type (grid_type), intent (inout) :: patch_out  ! May be the input patch

!     Local variables:

      integer :: i, j

!     Execution:

      do j = 1, patch%nj
         do i = 1, patch%ni
            patch_out%x(i,j,1) = scale * patch%x(i,j,1) + dx
            patch_out%y(i,j,1) = scale * patch%y(i,j,1) + dy
            patch_out%z(i,j,1) = scale * patch%z(i,j,1) + dz
         end do
      end do

      end subroutine scale_and_shift

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine swap_coordinates (patch, m, n)

!     Exchange the indicated pair of coordinates.

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      integer, intent (in) :: m, n        ! 1, 2, 3  <->  x, y, z

!     Local variables:

      integer :: ni, nj

!     Execution:

      ni = patch%ni;  nj = patch%nj

      select case (m)
         case (1)
            select case (n)
               case (2)
                  call swap (ni, nj, patch%x, patch%y)
               case (3)
                  call swap (ni, nj, patch%x, patch%z)
            end select
         case (2)
            select case (n)
               case (1)
                  call swap (ni, nj, patch%y, patch%x)
               case (3)
                  call swap (ni, nj, patch%y, patch%z)
            end select
         case (3)
            select case (n)
               case (1)
                  call swap (ni, nj, patch%z, patch%x)
               case (2)
                  call swap (ni, nj, patch%z, patch%y)
            end select
      end select

      contains

         subroutine swap (ni, nj, cm, cn)

         integer, intent (in)    :: ni, nj
         real,    intent (inout) :: cm(ni,nj,1), cn(ni,nj,1)
         integer :: i, j
         real    :: temp

!        Play safe by not assuming packed 2-D arrays.

         do j = 1, nj
            do i = 1, ni
               temp      = cm(i,j,1)
               cm(i,j,1) = cn(i,j,1)
               cn(i,j,1) = temp
            end do
         end do

         end subroutine swap

      end subroutine swap_coordinates

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine transpose_patch (patch, nf)

!     Reverse the i and j indices of a surface patch, in-place.

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch
      integer,          intent (in)    :: nf   ! # function values; nf >= 0

!     Local variables:

      integer          :: i, j, mi, mj, ni, nj
      real             :: t, tq(nf)
      type (grid_type) :: tpatch

!     Execution:

      ni = patch%ni;  nj = patch%nj

      allocate (tpatch%x(nj,ni,1), tpatch%y(nj,ni,1), tpatch%z(nj,ni,1))

      do j = 1, nj
         do i = 1, ni
            tpatch%x(j,i,1) = patch%x(i,j,1)
            tpatch%y(j,i,1) = patch%y(i,j,1)
            tpatch%z(j,i,1) = patch%z(i,j,1)
         end do
      end do

      deallocate (patch%x, patch%y, patch%z)
      patch%ni = nj;  patch%nj = ni
      allocate (patch%x(nj,ni,1), patch%y(nj,ni,1), patch%z(nj,ni,1))

      do j = 1, ni
         do i = 1, nj
            patch%x(i,j,1) = tpatch%x(i,j,1)
            patch%y(i,j,1) = tpatch%y(i,j,1)
            patch%z(i,j,1) = tpatch%z(i,j,1)
         end do
      end do

      deallocate (tpatch%x, tpatch%y, tpatch%z)

      if (nf > 0) then

         mi = patch%mi;  mj = patch%mj

         allocate (tpatch%q(nf,mj,mi,1))

         do j = 1, mj
            do i = 1, mi
               tpatch%q(:,j,i,1) = patch%q(:,i,j,1)
            end do
         end do

         deallocate (patch%q)
         patch%mi = mj;  patch%mj = mi
         allocate (patch%q(nf,mj,mi,1))

         do j = 1, mi
            do i = 1, mj
               patch%q(:,i,j,1) = tpatch%q(:,i,j,1)
            end do
         end do

         deallocate (tpatch%q)

      end if

      end subroutine transpose_patch

!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine update_patch (patch_in, nf, release_in, release_out, patch_out)

!     Transcribe one surface patch to another.
!     The output patch fields are (re)allocated here before the copy.
!     The input patch fields are deallocated after the copy if indicated.
!     The "release" arguments are adopted because of observed misbehavior with
!     if (allocated(...)) ...
!
!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Arguments:

      type (grid_type), intent (inout) :: patch_in    ! Surface patch to copy
      integer,          intent (in)    :: nf          ! # functions >= 0
      logical,          intent (in)    :: release_in  ! T => deallocate inputs
      logical,          intent (in)    :: release_out ! T => reallocate outputs
      type (grid_type), intent (inout) :: patch_out   ! x

!     Execution:

      if (release_out) then
         deallocate (patch_out%x, patch_out%y, patch_out%z)
         if (nf > 0) deallocate (patch_out%q)
      end if

      patch_out%ni = patch_in%ni
      patch_out%nj = patch_in%nj
      patch_out%nk = 1

      allocate (patch_out%x(patch_in%ni,patch_in%nj,1), &
                patch_out%y(patch_in%ni,patch_in%nj,1), &
                patch_out%z(patch_in%ni,patch_in%nj,1))

      patch_out%x = patch_in%x
      patch_out%y = patch_in%y
      patch_out%z = patch_in%z

      if (nf > 0) then
         patch_out%mi = patch_in%mi
         patch_out%mj = patch_in%mj
         patch_out%mk = 1
         allocate (patch_out%q(nf,patch_in%mi,patch_in%mj,1))
         patch_out%q  = patch_in%q
      end if

      if (release_in) then
         deallocate (patch_in%x, patch_in%y, patch_in%z)
         if (nf > 0) deallocate (patch_in%q)
      end if

      end subroutine update_patch

   end module surface_patch_utilities
